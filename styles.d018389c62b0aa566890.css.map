{"version":3,"file":"styles.d018389c62b0aa566890.css","mappings":"AAOuBA,KCFrB,kCAAmC,CACnC,iCAAkC,CDoBVC,mICtBZ,CDcaC,QCX3B,CAEA,KACE,uEAEF,CC2BkBC,SAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,sBAAAA,CAAAA,eAAAA,qBAAAA,CAUKC,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,wBAAAA,CAAAA,oBAAAA,CAAAA,gBAAAA,CAAAA,OAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CASLC,SAAAA,oBAAAA,CAAAA,eAAAA,CAqDIC,SAAAA,cAAAA,CAAAA,eAAAA,CC/FJC,UAAAA,YAAAA,CAAAA,QAAAA,CAAAA,6FAAAA,CAAAA,+CAAAA,CAAAA,WAAAA,CAAAA,eAAAA,CAAAA,kBAAAA,CAmCDC,SAAAA,kBAAAA,CAMEC,UAAAA,eAAAA,CAqBKC,UAAAA,YAAAA,CAAAA,UAAAA,CAAAA,qCAAAA,CA8CVC,iCAAAA,qBAAAA,CAAAA,aAAAA,cAAAA,CAmGOC,SAAAA,eAAAA,CAmCJC,SAAAA,kBAAAA,CAgBAC,UAAAA,2BAAAA,CAAAA,iBAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CC3QMd,mBAAAA,WAAAA,CAAAA,eAAAA,CAWIE,UAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,0BAAAA,CAAAA,kBAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,oBAAAA,CAAAA,UAAAA,CAQDD,UAAAA,aAAAA,CAAAA,cAAAA,CAKZc,UAAAA,SAAAA","sources":["App.tsx","index.css","src/ScriptTimingTree.tsx","src/FileRenderer.tsx","src/App.tsx"],"sourcesContent":["import { css } from \"@linaria/core\";\nimport { styled } from \"@linaria/react\";\nimport { ChangeEvent, useCallback } from \"react\";\nimport useStore from \"./store\";\nimport { parseProfilingData } from \"./lua\";\nimport FileRenderer from \"./FileRenderer\";\n\nexport const globals = css`\n  :global() {\n    html,\n    body,\n    div#root {\n      height: 100%;\n      max-width: 100vw;\n    }\n  }\n`;\n\nconst CenteringContainer = styled.div`\n  display: grid;\n  justify-items: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n`;\n\nconst profilingLabelCss = css`\n  display: block;\n  font-size: 2rem;\n`;\n\nconst Error = styled.div`\n  color: red;\n`;\n\nfunction FilePickerPage() {\n  const { setProfilingData, clearProfilingData, setParseError, parseError } =\n    useStore(\n      ({\n        setProfilingData,\n        clearProfilingData,\n        setParseError,\n        parseError,\n      }) => ({\n        setProfilingData,\n        clearProfilingData,\n        setParseError,\n        parseError,\n      })\n    );\n\n  const onFileChange = useCallback(\n    (event: ChangeEvent<HTMLInputElement>) => {\n      const files = event.target.files;\n      if (files && files.length > 0) {\n        files[0].text().then((raw) => {\n          const data = parseProfilingData(raw);\n          if (data) {\n            setProfilingData(data);\n          } else {\n            setParseError(true);\n          }\n        });\n      } else {\n        clearProfilingData();\n      }\n    },\n    [setProfilingData, clearProfilingData, setParseError]\n  );\n\n  return (\n    <CenteringContainer>\n      <div>\n        <label className={profilingLabelCss} htmlFor=\"file-picker\">\n          Select profiling data\n        </label>\n        <input\n          type=\"file\"\n          id=\"file-picker\"\n          onChange={onFileChange}\n          accept=\".lua\"\n        />\n        {parseError && <Error>Unable to parse input.</Error>}\n      </div>\n    </CenteringContainer>\n  );\n}\n\nfunction App() {\n  const hasProfilingData = useStore(\n    (state) => state.profilingData !== undefined\n  );\n  if (!hasProfilingData) {\n    return <FilePickerPage />;\n  }\n  return <FileRenderer />;\n}\n\nexport default App;\n","body {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\",\n    \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\",\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\ncode {\n  font-family: source-code-pro, Menlo, Monaco, Consolas, \"Courier New\",\n    monospace;\n}\n","import { styled } from \"@linaria/react\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { ScriptTiming } from \"./lua\";\nimport useStore, { useSelectedRecording, useStoreKey } from \"./store\";\nimport { build, FrameTree } from \"./tree\";\n\nexport type TimingEntry = {\n  callCount?: number;\n  totalTime: number;\n};\n\nfunction toTimingTree(\n  sourceTree: FrameTree<[string, ScriptTiming] | undefined>\n): FrameTree<TimingEntry> {\n  const children: [string, FrameTree<TimingEntry>][] = Object.entries(\n    sourceTree.children\n  ).map(([k, v]) => [k, toTimingTree(v)]);\n\n  const originalEntry = sourceTree.value?.[1];\n\n  const value = originalEntry\n    ? {\n        callCount: originalEntry.callCount,\n        totalTime: originalEntry.debugTime,\n      }\n    : {\n        totalTime: children.reduce(\n          (totalTime, [, value]) => value.value.totalTime + totalTime,\n          0\n        ),\n      };\n\n  return {\n    ...sourceTree,\n    children: Object.fromEntries(children),\n    value,\n  };\n}\n\nconst NodeLabel = styled.div`\n  overflow: hidden;\n  text-overflow: ellipsis;\n  background-color: #eee;\n\n  &:hover {\n    background-color: #aaa;\n  }\n`;\n\nconst ChildContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  place-items: start;\n  gap: 2px;\n  max-width: 100%;\n`;\n\nconst ChildNode = styled.div`\n  display: inline-block;\n  overflow: hidden;\n`;\n\nfunction TimingTreeNode({\n  node,\n  parentTime,\n  expanded,\n}: {\n  expanded?: boolean;\n  parentTime: number;\n  node: FrameTree<TimingEntry>;\n}) {\n  const width = node.value.totalTime / parentTime;\n\n  const focusedNode = useStore((state) => state.focusedNode);\n  const setFocusedNode = useStore((state) => state.setFocusedNode);\n  const clearFocusedNode = useStore((state) => state.clearFocusedNode);\n\n  const onClick = useCallback(() => {\n    if (focusedNode === node) {\n      clearFocusedNode();\n    } else {\n      setFocusedNode(node);\n    }\n  }, [node, focusedNode, setFocusedNode, clearFocusedNode]);\n\n  if (node.value.totalTime < 1) {\n    return null;\n  }\n\n  return (\n    <ChildNode style={{ width: `${width * 100 * (expanded ? 2 : 1)}%` }}>\n      <NodeLabel\n        title={`${node.name} (${node.value.totalTime.toFixed(2)} ms)`}\n        onClick={onClick}\n      >\n        {node.name}\n      </NodeLabel>\n      <ChildContainer>\n        {Object.entries(node.children).map(([key, child]) => (\n          <TimingTreeNode\n            key={key}\n            node={child}\n            parentTime={node.value.totalTime}\n          />\n        ))}\n      </ChildContainer>\n    </ChildNode>\n  );\n}\n\nconst TreeContainer = styled.details`\n  max-width: 100%;\n  overflow-x: auto;\n`;\n\nconst ExpandButton = () => {\n  const setExpanded = useStoreKey(\"setExpandScriptTimingChart\");\n  const isExpanded = useStoreKey(\"expandScriptTimingChart\");\n\n  return (\n    <button onClick={() => setExpanded(!isExpanded)}>\n      {isExpanded ? \"Zoom Out\" : \"Zoom In\"}\n    </button>\n  );\n};\n\nconst ClearFocusButton = () => {\n  const clearFocus = useStoreKey(\"clearFocusedNode\");\n\n  return <button onClick={() => clearFocus()}>Clear Focus</button>;\n};\n\nexport default function ScriptTimingTree(): JSX.Element | null {\n  const recording = useSelectedRecording();\n\n  const focusedNode = useStoreKey(\"focusedNode\");\n  const clearFocusedNode = useStoreKey(\"clearFocusedNode\");\n  const isExpanded = useStoreKey(\"expandScriptTimingChart\");\n\n  const tree = useMemo(\n    () =>\n      recording &&\n      toTimingTree(build(Object.entries(recording.data.fn), ([key]) => key)),\n    [recording]\n  );\n\n  useEffect(() => {\n    clearFocusedNode();\n  }, [tree, clearFocusedNode]);\n\n  if (!tree) {\n    return null;\n  }\n\n  const node = focusedNode ?? tree;\n\n  return (\n    <TreeContainer>\n      <summary>Script Timing</summary>\n      <p>\n        This shows the recording time spent on every script attached to every\n        frame (except for a few unhookable internal frames).\n      </p>\n      <p>Subtrees that took less than 1ms of script time are not shown.</p>\n      <TimingTreeNode\n        expanded={isExpanded}\n        node={node}\n        parentTime={node.value.totalTime}\n      />\n      <div>\n        <ExpandButton /> {focusedNode && <ClearFocusButton />}\n      </div>\n    </TreeContainer>\n  );\n}\n","import { css } from \"@linaria/core\";\nimport { styled } from \"@linaria/react\";\nimport { useEffect, useMemo } from \"react\";\nimport {\n  Encounter,\n  FrameCreation,\n  isBossEncounter,\n  NamedFrameCreation,\n} from \"./lua\";\nimport ScriptTimingTree from \"./ScriptTimingTree\";\nimport useStore, {\n  useProfilingData,\n  useSelectedRecording,\n  useStoreKey,\n} from \"./store\";\n\nconst Container = styled.div`\n  display: grid;\n  grid-template-areas:\n    \"sidebar encounter\"\n    \"sidebar addons\"\n    \"sidebar functions\"\n    \"sidebar frames\";\n  grid-template-columns: max-content minmax(0, 1fr);\n  height: 100%;\n  max-width: 100vw;\n  gap: 1rem;\n  padding-right: 1rem;\n`;\n\nconst formatStartTime = (startTime: number) => {\n  const date = new Date(startTime * 1000);\n\n  return Intl.DateTimeFormat(undefined, {\n    year: \"numeric\",\n    month: \"short\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"numeric\",\n  }).format(date);\n};\n\nconst EncounterEntry = ({\n  encounter,\n  onClick,\n}: {\n  encounter: Encounter;\n  onClick: () => void;\n}) => {\n  return (\n    <div\n      className={css`\n        margin-bottom: 1rem;\n      `}\n      onClick={onClick}\n    >\n      <div\n        className={css`\n          font-weight: bold;\n        `}\n      >\n        {encounter.encounterName}\n      </div>\n      <div>\n        <span>{formatStartTime(encounter.startTime)}</span>\n      </div>\n    </div>\n  );\n};\n\nfunction formatDuration(seconds: number): string {\n  if (seconds >= 60) {\n    return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;\n  }\n\n  return `${seconds}s`;\n}\n\nconst DescriptionList = styled.dl`\n  display: grid;\n  grid-template-columns: max-content 1fr;\n  gap: 0 1rem;\n`;\n\nconst EncounterTable = () => {\n  const recording = useSelectedRecording();\n\n  if (!recording) {\n    return null;\n  }\n\n  const encounter = recording.encounter;\n\n  return (\n    <details>\n      <summary>Encounter Details</summary>\n      <DescriptionList>\n        <dt>Encounter/Map ID</dt>\n        <dd>\n          {isBossEncounter(encounter) ? encounter.encounterId : encounter.mapId}\n        </dd>\n        <dt>Encounter Name</dt>\n        <dd>{encounter.encounterName}</dd>\n        <dt>Start Time</dt>\n        <dd>{formatStartTime(encounter.startTime)}</dd>\n        <dt>End Time</dt>\n        <dd>{formatStartTime(encounter.endTime)}</dd>\n        <dt>Duration</dt>\n        <dd>{formatDuration(encounter.endTime - encounter.startTime)}</dd>\n        {isBossEncounter(encounter) ? (\n          <>\n            <dt>Result</dt>\n            <dd>{encounter.success ? \"Kill\" : \"Wipe\"}</dd>\n            <dt>Group Size</dt>\n            <dd>{encounter.groupSize}</dd>\n            <dt>Difficulty ID</dt>\n            <dd>{encounter.difficultyId}</dd>\n          </>\n        ) : null}\n      </DescriptionList>\n    </details>\n  );\n};\n\nconst Table = styled.table`\n  tbody tr:nth-child(even) {\n    background-color: #eee;\n  }\n\n  td {\n    padding: 0 1rem;\n  }\n`;\n\nconst FrameCreationsTable = () => {\n  const recording = useSelectedRecording();\n\n  if (!recording) {\n    return null;\n  }\n\n  const frames = (\n    recording.data.CreateFrame.anonymous as (\n      | FrameCreation\n      | NamedFrameCreation\n    )[]\n  )\n    .concat(Object.values(recording.data.CreateFrame.named))\n    .sort((a, b) => a.creationTime - b.creationTime);\n\n  return (\n    <details>\n      <summary>Frame Creations</summary>\n      <p>\n        This shows the mid-combat frame creations. Creating a frame is\n        relatively expensive, and while it <em>can</em> be okay to create them\n        in combat, creating a lot of them is likely to cause performance issues.\n      </p>\n      <Table>\n        <thead>\n          <tr>\n            <td>Frame Name</td>\n            <td>Frame Type</td>\n            <td>Time of Creation</td>\n            <td>Parent</td>\n            <td>Template</td>\n          </tr>\n        </thead>\n        <tbody>\n          {frames.map((frame, ix) => (\n            <tr key={ix}>\n              <td>{\"name\" in frame ? frame.name : <em>Anonymous</em>}</td>\n              <td>{frame.frameType}</td>\n              <td>\n                {formatDuration(\n                  frame.creationTime - recording.encounter.startTime\n                )}\n              </td>\n              <td>{frame.parent}</td>\n              <td>{frame.template}</td>\n            </tr>\n          ))}\n        </tbody>\n      </Table>\n    </details>\n  );\n};\n\nconst AddonTable = () => {\n  const recording = useSelectedRecording();\n  const addon = recording?.data.addon;\n\n  const entries = useMemo(\n    () =>\n      addon &&\n      Object.entries(addon)\n        .filter(([, addon]) => addon.time > 1)\n        .sort(([, a], [, b]) => b.time - a.time),\n    [addon]\n  );\n\n  if (!addon) {\n    return null;\n  }\n\n  // this value is already in seconds\n  const totalTime = recording.encounter.endTime - recording.encounter.startTime;\n\n  // number of frames that should be rendered at 60 fps\n  const frameCount = totalTime * 60;\n  const frameLength = 1000 / 60;\n\n  return (\n    <details>\n      <summary>Addon Overview</summary>\n      <p>\n        This shows the amount of time spent in each addon's code according to\n        the WoW API. This does not include time spent on calls from addon code\n        into Blizzard's APIs (such as time spent creating frames).\n      </p>\n      <p>Only addons that took at least 1ms of script time are shown.</p>\n      <Table>\n        <thead\n          className={css`\n            font-weight: bold;\n          `}\n        >\n          <tr>\n            <td>Addon Name</td>\n            <td>Reported Time (ms)</td>\n            <td>Combat Time (%)</td>\n            <td>Time per Frame @ 60 FPS (ms)</td>\n            <td>60 FPS Frame Time (%)</td>\n          </tr>\n        </thead>\n        <tbody>\n          {entries?.map(([key, entry]) => (\n            <tr key={key}>\n              <td>{entry.name}</td>\n              <td>{entry.time.toFixed(2)}</td>\n              <td>{((entry.time / (totalTime * 1000)) * 100).toFixed(2)}</td>\n              <td>{(entry.time / frameCount).toFixed(2)}</td>\n              <td>\n                {((entry.time / frameCount / frameLength) * 100).toFixed(2)}\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </Table>\n    </details>\n  );\n};\n\nconst ClearButton = () => {\n  const reset = useStoreKey(\"clearProfilingData\");\n\n  return (\n    <button\n      className={css`\n        margin-bottom: 1rem;\n      `}\n      onClick={reset}\n    >\n      Clear\n    </button>\n  );\n};\n\nconst Sidebar = () => {\n  const data = useProfilingData();\n  const selectEncounter = useStore((state) => state.selectRecording);\n\n  return (\n    <div\n      className={css`\n        grid-area: sidebar;\n        padding: 1rem;\n        border-right: 1px solid black;\n        height: 100%;\n      `}\n    >\n      <ClearButton />\n      {data?.recordings.map(({ encounter }, index) => (\n        <EncounterEntry\n          key={encounter.startTime}\n          encounter={encounter}\n          onClick={() => selectEncounter(index)}\n        />\n      ))}\n    </div>\n  );\n};\n\nexport default function FileRenderer(): JSX.Element {\n  const initialize = useStore((state) => state.resetView);\n\n  useEffect(() => {\n    initialize();\n  }, [initialize]);\n\n  return (\n    <Container>\n      <Sidebar />\n      <EncounterTable />\n      <AddonTable />\n      <ScriptTimingTree />\n      <FrameCreationsTable />\n    </Container>\n  );\n}\n","import { css } from \"@linaria/core\";\nimport { styled } from \"@linaria/react\";\nimport { ChangeEvent, useCallback } from \"react\";\nimport useStore from \"./store\";\nimport { parseProfilingData } from \"./lua\";\nimport FileRenderer from \"./FileRenderer\";\n\nexport const globals = css`\n  :global() {\n    html,\n    body,\n    div#root {\n      height: 100%;\n      max-width: 100vw;\n    }\n  }\n`;\n\nconst CenteringContainer = styled.div`\n  display: grid;\n  justify-items: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n`;\n\nconst profilingLabelCss = css`\n  display: block;\n  font-size: 2rem;\n`;\n\nconst Error = styled.div`\n  color: red;\n`;\n\nfunction FilePickerPage() {\n  const { setProfilingData, clearProfilingData, setParseError, parseError } =\n    useStore(\n      ({\n        setProfilingData,\n        clearProfilingData,\n        setParseError,\n        parseError,\n      }) => ({\n        setProfilingData,\n        clearProfilingData,\n        setParseError,\n        parseError,\n      })\n    );\n\n  const onFileChange = useCallback(\n    (event: ChangeEvent<HTMLInputElement>) => {\n      const files = event.target.files;\n      if (files && files.length > 0) {\n        files[0].text().then((raw) => {\n          const data = parseProfilingData(raw);\n          if (data) {\n            setProfilingData(data);\n          } else {\n            setParseError(true);\n          }\n        });\n      } else {\n        clearProfilingData();\n      }\n    },\n    [setProfilingData, clearProfilingData, setParseError]\n  );\n\n  return (\n    <CenteringContainer>\n      <div>\n        <label className={profilingLabelCss} htmlFor=\"file-picker\">\n          Select profiling data\n        </label>\n        <input\n          type=\"file\"\n          id=\"file-picker\"\n          onChange={onFileChange}\n          accept=\".lua\"\n        />\n        {parseError && <Error>Unable to parse input.</Error>}\n      </div>\n    </CenteringContainer>\n  );\n}\n\nfunction App() {\n  const hasProfilingData = useStore(\n    (state) => state.profilingData !== undefined\n  );\n  if (!hasProfilingData) {\n    return <FilePickerPage />;\n  }\n  return <FileRenderer />;\n}\n\nexport default App;\n"],"names":[".guwg8pj",".p1q6qxdt",".c1llctjr",".nz8logi",".c1rdqr83",".cc3hdgt",".t3gdfh3",".c1odvvwr",".dx0qwzu",".d11l1ypd",".d1jauilc",".t1i3iq1b",".trtem5d",".bgd5qh0",".d12yj61e",".e1u5xbpx"],"sourceRoot":""}